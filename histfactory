#!/usr/bin/env python

import os
from math import sqrt
from itertools import izip

import ROOT
import rootpy; rootpy.log.basic_config_colorized()
from rootpy.io import root_open
from rootpy.plotting import Hist
from rootpy.utils.silence import silence_sout
from rootpy.context import do_nothing

import logging; log = logging.getLogger(os.path.basename(__file__))


def process_measurement(m,
                        fill_empties=False,
                        fill_empties_samples=None,
                        fill_empties_channels=None,
                        rebin=1,
                        rebin_channels=None,
                        merge_bins=None,
                        merge_bins_channels=None,
                        smooth_histosys=False,
                        smooth_histosys_channels=None,
                        smooth_histosys_iterations=1,
                        prune_histosys=False,
                        prune_histosys_channels=None,
                        prune_histosys_method='max',
                        prune_histosys_threshold=0.1,
                        prune_overallsys=False,
                        prune_overallsys_channels=None,
                        prune_overallsys_threshold=0.5,
                        uniform_binning=False):

    for c in m.channels:
        log.info(
            "processing measurement `{0}` channel `{1}` ...".format(
                m.name, c.name))
        # rebin
        if rebin != 1 and (not rebin_channels or c.name in rebin_channels):
            c.data.hist = apply_rebin(c.data.hist, rebin)
            for s in c.samples:
                log.info("applying rebinning {0:d} on sample `{1}`".format(rebin, s.name))
                s.hist = apply_rebin(s.hist, rebin)
                for histosys in s.histo_sys:
                    histosys.high = apply_rebin(histosys.high, rebin)
                    histosys.low = apply_rebin(histosys.low, rebin)

        # merge bins
        if merge_bins and (not merge_bins_channels or c.name in merge_bins_channels):
            c.data.hist = apply_merge_bins(c.data.hist, merge_bins)
            for s in c.samples:
                log.info("merging bins {0} in sample `{1}`".format(
                    ', '.join([':'.join(map(str, r)) for r in merge_bins]),
                    s.name))
                s.hist = apply_merge_bins(s.hist, merge_bins)
                for histosys in s.histo_sys:
                    histosys.high = apply_merge_bins(histosys.high, merge_bins)
                    histosys.low = apply_merge_bins(histosys.low, merge_bins)

        # apply fill_empties
        if fill_empties and (not fill_empties_channels or c.name in fill_empties_channels):
            for s in c.samples:
                if fill_empties_samples and s.name not in fill_empties_samples:
                    continue
                if not is_signal(s):
                    log.info("applying fill_empties on sample `{0}`".format(s.name))
                    s.hist = apply_fill_empties(s.hist)
                    for histosys in s.histo_sys:
                        histosys.high = apply_fill_empties(histosys.high)
                        histosys.low = apply_fill_empties(histosys.low)

        # smooth
        if smooth_histosys and (not smooth_histosys_channels or c.name in smooth_histosys_channels):
            for s in c.samples:
                for histosys in s.histo_sys:
                    smooth_shape(s.hist, histosys, smooth_histosys_iterations)

        # prune shapes
        if prune_histosys and (not prune_histosys_channels or c.name in prune_histosys_channels):
            
            # total bkg needed for max method
            if prune_histosys_method == 'max':
                total_bkg = sum([s.hist.Clone(shallow=True) for s in c.samples if not is_signal(s)])

            for s in c.samples:
                # don't prune shapes from signal
                if is_signal(s):
                    continue

                names = []
                if prune_histosys_method == 'max':
                    for histosys in s.histo_sys:
                        if not shape_is_significant(total_bkg, histosys.high, histosys.low, prune_histosys_threshold):
                            names.append(histosys.name)

                elif prune_histosys_method == 'chi2':
                    for histosys in s.histo_sys:
                        if not shape_chi2_test(s.hist, histosys.high, histosys.low, prune_histosys_threshold):
                            names.append(histosys.name)

                elif prune_histosys_method == 'ks':
                    for histosys in s.histo_sys:
                        if (histosys.high.KolmogorovTest(s.hist) < prune_histosys_threshold and
                            histosys.low.KolmogorovTest(s.hist) < prune_histosys_threshold):
                            names.append(histosys.name)
                
                for name in names:
                    log.info("removing HistoSys `{0}` from sample `{1}` using method `{2}`".format(
                        name, s.name, prune_histosys_method))
                    s.RemoveHistoSys(name)

        # prune overallsys
        if prune_overallsys and (not prune_overallsys_channels or c.name in prune_overallsys_channels):
            for s in c.samples:
                names = []
                for overallsys in s.overall_sys:
                    if (abs(overallsys.high - 1.) * 100. < prune_overallsys_threshold and
                        abs(overallsys.low - 1.) * 100. < prune_overallsys_threshold):
                        names.append(overallsys.name)
                for name in names:
                    log.info("removing OverallSys `{0}` from sample `{1}`".format(name, s.name))
                    s.RemoveOverallSys(name)

        # convert to uniform binning
        if uniform_binning:
            c.data.hist = to_uniform_binning(c.data.hist)
            for s in c.samples:
                s.hist = to_uniform_binning(s.hist)
                for histosys in s.histo_sys:
                    histosys.high = to_uniform_binning(histosys.high)
                    histosys.low = to_uniform_binning(histosys.low)
        
        # zero out negatives
        for s in c.samples:
            s.hist = zero_negs(s.hist)
            for histosys in s.histo_sys:
                histosys.high = zero_negs(histosys.high)
                histosys.low = zero_negs(histosys.low)


def shape_chi2_test(nom, up, down, threshold):
    """
    Calculate the Chi^2 of the up and down variations and return True the
    variations are significant given a threshold on the minimum Chi^2 value.
    """
    chi2up = 0.
    chi2dn = 0.
    nbin = 0
    for nom_bin, up_bin, down_bin in izip(
            nom.bins(overflow=False),
            up.bins(overflow=False),
            down.bins(overflow=False)):
        n = nom_bin.value
        u = up_bin.value
        d = down_bin.value
        eup = max(nom_bin.error, up_bin.error)
        edn = max(nom_bin.error, down_bin.error)
        if not (n > 0. and eup > 0. and edn > 0.):
            continue
        chi2up += ((u - n) / eup) ** 2.
        chi2dn += ((d - n) / edn) ** 2.
        nbin += 1
    chi2up = ROOT.TMath.Prob(chi2up, nbin)
    chi2dn = ROOT.TMath.Prob(chi2dn, nbin)
    # return True if the shape should be kept
    return min(chi2up, chi2dn) <= threshold


def shape_is_significant(total, high, low, threshold=0.1):
    """
    For a given shape systematic calculate ``s_i=|up_i-down_i|/stat_total_i``,
    where ``up_i`` is up variation in ``bin_i``, ``down_i`` is down variation
    in ``bin_i``, ``stat_total_i`` is the statistical uncertainty for total
    background prediction in ``bin_i``. If ``max(s_i)<0.1``, then drop this
    shape systematic.
    """
    for bin_total, bin_high, bin_low in zip(
            total.bins(), high.bins(), low.bins()):
        diff = abs(bin_high.value - bin_low.value)
        if bin_total.error == 0:
            if diff != 0:
                return True
            continue
        sig = abs(bin_high.value - bin_low.value) / bin_total.error
        if sig > threshold:
            return True
    return False


def smooth_shape(nominal, histosys, iterations=1):
    """
    Smooth shape systematics with respect to the nominal histogram by applying
    TH1::Smooth() on the ratio of systematic / nominal.
    """
    log.info("smoothing HistoSys `{0}`".format(histosys.name))
    high_name = histosys.high.name + '_smoothed_{0}'.format(iterations)
    low_name = histosys.low.name + '_smoothed_{0}'.format(iterations)
    ratio_high = histosys.high / nominal
    ratio_low = histosys.low / nominal
    ratio_high.Smooth(iterations)
    ratio_low.Smooth(iterations)
    histosys.high = ratio_high * nominal
    histosys.low = ratio_low * nominal
    histosys.high.name = high_name
    histosys.low.name = low_name


def to_uniform_binning(hist):
    """ 
    For some obscure technical reason, HistFactory can't handle histograms with
    variable width bins. This function takes any histogram and outputs a new
    histogram with constant width bins along all axes by using the bin indices
    of the input histogram as the x-axis of the new histogram.
    """
    log.info("converting histogram `{0}` to uniform binning".format(hist.name))
    if hist.GetDimension() == 1:
        new_hist = Hist(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    elif hist.GetDimension() == 2:
        new_hist = Hist2D(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            hist.GetNbinsY(), 0, hist.GetNbinsY(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    elif hist.GetDimension() == 3:
        new_hist = Hist3D(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            hist.GetNbinsY(), 0, hist.GetNbinsY(),
            hist.GetNbinsZ(), 0, hist.GetNbinsZ(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    else:
        raise TypeError(
            "unable to apply uniform binning on object "
            "of type {0}".format(type(hist)))
    # copy over the bin contents and errors
    for outbin, inbin in izip(new_hist.bins(), hist.bins()):
        outbin.value = inbin.value
        outbin.error = inbin.error
    return new_hist


def zero_negs(hist):
    """ 
    Return a clone of this histogram with all negative bins set to zero. The
    errors of these bins are left untouched.
    """
    new_hist = hist.Clone(name=hist.name + '_nonegs', shallow=True)
    applied = False
    for bin in new_hist.bins():
        if bin.value < 0:
            applied = True
            log.warning(
                "zeroing negative bin {0:d} in `{1}`".format(
                    bin.idx, hist.name))
            bin.value = 0.
    if applied:
        return new_hist
    return hist


def apply_merge_bins(hist, bin_ranges, axis=0):
    """
    Merge ranges of bins by bin indices.
    `bin_ranges` is a list of 2-tuples of bin index ranges.
    `axis` is the axis along which to merge the bins (0, 1, or 2)
    """
    new_hist = hist.merge_bins(bin_ranges, axis=axis)
    new_hist.name = hist.name + '_merged'
    return new_hist


def apply_rebin(hist, n):
    """
    Rebin the histogram with TH1::Rebin
    """
    if n < 2:
        return hist
    new_hist = hist.Clone(name=hist.name + '_rebin_{0:d}'.format(n), shallow=True)
    new_hist.Rebin(n)
    return new_hist


def apply_fill_empties(hist):
    """
    Return a clone of the input histogram where the empty bins have been filled
    with the average weight and the errors of these bins set to sqrt(<w^2>).
    If no bins were altered, then return the original histogram
    """
    fixed_hist = hist.Clone(name=hist.name + '_fill_empties', shallow=True)

    sumW2TotBin = sum([bin.error**2 for bin in hist.bins()])
    avWeightBin = hist.GetSumOfWeights() / hist.GetEntries()
    avW2Bin = sumW2TotBin / hist.GetEntries()

    applied = False
    for bin in fixed_hist.bins():
        if bin.value < 1E-6:
            log.warning(
                "filling empty or negative bin {0:d} in `{1}` with average weight".format(
                    bin.idx, hist.name))
            bin.value = avWeightBin
            bin.error = sqrt(avW2Bin)
            applied = True
    
    if applied:
        return fixed_hist
    return hist


def is_signal(sample, poi='SigXsecOverSM'):
    for norm in sample.GetNormFactorList():
        if norm.name == poi:
            return True
    return False


def equal(left, right, precision=1E-7):
    return abs(left - right) < precision


def _get_named(sequence, name):
    for i, thing in enumerate(sequence):
        if thing.GetName() == name:
            return i, thing
    return None, None


def partitioning(left, right):
    """
    Partition each collection into three sets containing the elements that
    overlap between the collections, elements that are only found in the left
    collection and elements that are only found in the right collection.
    """
    overlap = []
    left_only  = []
    right_only = right[:]
    for thing in left:
        idx, other = _get_named(right_only, thing.name)
        if idx is not None:
            overlap.append((thing, other))
            right_only.pop(idx)
        else:
            left_only.append(thing)
    return overlap, left_only, right_only


def _diff_sequence_helper(left, right, diff_func, parent=None, **kwargs):
    
    differ = False
    overlap, left_only, right_only = partitioning(
        left, right)
    for left_o, right_o in overlap:
        _differ = diff_func(left_o, right_o, **kwargs)
        if _differ:
            if parent is not None:
                log.warning(
                    "{0} differs in {1}".format(
                        left_o, parent))
            else:
                log.warning(
                    "{0} differs".format(
                        left_o))
            differ = _differ
    for coll, sym in ((left_only, '<'), (right_only, '>')):
        for thing in coll:
            log.warning("{0} {1} {2}".format(parent, sym, thing))
            differ = True
    return differ


def diff_histograms(left, right, compare_edges=False, precision=1E-7):

    # compare dimensionality
    if left.GetDimension() != right.GetDimension():
        log.warning(
            "histgrams {0} and {1} differ in dimensionality: {2:d} and {3:d}".format(
                left.name, right.name,
                left.GetDimension(), right.GetDimension()))
        return True
    # compare axis
    axis_names = 'xyz'
    for axis in xrange(left.GetDimension()):
        if left.nbins(axis) != right.nbins(axis):
            log.warning(
                "histograms {0} and {1} differ in the number of bins "
                "along the {2}-axis: {3:d} {4:d}".format(
                    left.name, right.name, axis_names[axis],
                    left.nbins(axis),
                    right.nbins(axis)))
            return True
    differ = False
    # compare contents and errors
    for left_bin, right_bin in izip(left.bins(), right.bins()):
        if not equal(left_bin.value, right_bin.value, precision=precision):
            log.warning(
                "histgrams {0} and {1} differ in content in bin {2:d}: {3:f} {4:f}".format(
                    left.name, right.name, left_bin.idx,
                    left_bin.value, right_bin.value))
            differ = True
        if not equal(left_bin.error, right_bin.error, precision=precision):
            log.warning(
                "histgrams {0} and {1} differ in error in bin {2:d}: {3:f} {4:f}".format(
                    left.name, right.name, left_bin.idx,
                    left_bin.error, right_bin.error))
            differ = True
    return differ


def diff_overallsys(left, right, precision=1E-7):
    
    differ = False
    if not equal(left.low, right.low, precision=precision):
        differ = True
        log.warning("OverallSys {0} differs for low values: {1:f} {2:f}".format(
            left.name, left.low, right.low))
    if not equal(left.high, right.high, precision=precision):
        differ = True
        log.warning("OverallSys {0} differs for high values: {1:f} {2:f}".format(
            left.name, left.high, right.high))
    return differ


def diff_histosys(left, right, precision=1E-7):

    differ = False
    if diff_histograms(left.low, right.low, precision=precision):
        differ = True
    if diff_histograms(left.high, right.high, precision=precision):
        differ = True
    return differ
    

def diff_samples(left, right, precision=1E-7):
    
    # compare nominal
    differ = diff_histograms(left.hist, right.hist, precision=precision)
    # compare OverallSys
    _differ = _diff_sequence_helper(left.overall_sys, right.overall_sys,
        diff_func=diff_overallsys, parent=left, precision=precision)
    if _differ:
        differ = differ
    # compare HistoSys
    _differ = _diff_sequence_helper(left.histo_sys, right.histo_sys,
        diff_func=diff_histosys, parent=left, precision=precision)
    if _differ:
        differ = differ
    return differ


def diff_channels(left, right, precision=1E-7):

    return _diff_sequence_helper(left.samples, right.samples,
        diff_func=diff_samples, parent=left, precision=precision)


def diff_measurements(left, right, precision=1E-7):

    return _diff_sequence_helper(left.channels, right.channels,
        diff_func=diff_channels, parent=left, precision=precision)


if __name__ == '__main__':
    
    from rootpy.extern import argparse
    
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False,
        description="""
A script for common operations on HistFactory workspaces.

This script can:

* patch HistFactory XML files by cleaning up the formatting and fixing known
  issues that trigger HistFactory bugs
* list the differences between two workspaces (including differences at the
  histogram level)
* convert histograms to uniform binning
* rebin histograms
* merge specific bins in histograms
* smooth shape (HistoSys) systematics
* prune normalization (OverallSys) systematics
* prune shape (HistoSys) systematics by three separate methods: maximum
  deviation relative to total background statistical uncertainty, Chi2, and KS
* fill empty background bins with the average sample weights

A new ROOT file and new set of XML files will be written out alongside the 
input files with one or more of the above modifications.""")
    
    parser.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")
    parser.add_argument('--verbose', action='store_true', default=False,
        help="Show all HistFactory/RooStats output")

    subparsers = parser.add_subparsers()

    
    parser_diff = subparsers.add_parser('diff',
        description="List the differences between two workspaces",
        add_help=False)
    
    parser_diff.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")

    parser_diff.add_argument('-p', '--precision', type=float, default=1E-7,
        help="Precision for comparing if two floats are equal (default: 1E-7)")

    parser_diff.add_argument('left')
    parser_diff.add_argument('right')
    parser_diff.set_defaults(op='diff')

    
    parser_patch = subparsers.add_parser('patch',
        description="Patch HistFactory XML files",
        add_help=False)

    parser_patch.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")
    
    parser_patch.add_argument('-p', '--precision', type=int, default=3,
        help="Number of decimal places to keep in all floats (default: 3)")

    parser_patch.add_argument('files', nargs='+',
        help="HistFactory XML files")
    
    parser_patch.set_defaults(op='patch')


    parser_ws = subparsers.add_parser('ws',
        description="Create a new workspace with optional modifications",
        add_help=False)
    
    parser_ws.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")
    
    parser_ws.add_argument('--fill-empties', action='store_true', default=False,
        help="Fill empty background bins per sample with the average weight and set "
             "the errors of these bins to sqrt(<w^2>)")
    parser_ws.add_argument('--fill-empties-samples', nargs='*',
        help="Restrict application of --fill-empties to these samples (default: all samples)")
    parser_ws.add_argument('--fill-empties-channels', nargs='*',
        help="Restrict application of --fill-empties to these channels (default: all channels)")

    parser_ws.add_argument('--rebin', type=int, default=1,
        help="Rebin histograms by grouping each N bins. "
             "Use --rebin 2 to merge every group of 2 bins (default: no rebinning)")
    parser_ws.add_argument('--rebin-channels', nargs='*',
        help="Restrict the rebinning to these channels (default: all channels)")

    parser_ws.add_argument('--merge-bins', nargs='*',
        help="Merge bins by ranges of bin indices. "
             "For example, use 1:-12 to merge left bins such that 10 bins on the right "
             "are untouched. Use 1:5 6:10 to merge bins 1 to 5 into one bin and 6 to 10 into one bin. "
             "Note that overflow bin indices are included in the indexing and "
             "that bin index ranges are inclusive of the low and high indices. (default: do not merge bins)")
    parser_ws.add_argument('--merge-bins-channels', nargs='*',
        help="Restrict bin merging to these channels (default: all channels)")

    parser_ws.add_argument('--smooth-histosys', action='store_true', default=False,
        help="Smooth HistoSys histograms (default: False)")
    parser_ws.add_argument('--smooth-histosys-iterations', type=int, default=1,
        help="Number of smoothing iterations in TH1::Smooth(N) to use when "
             "smoothing HistoSys (default: 1)")
    parser_ws.add_argument('--smooth-histosys-channels', nargs='*',
        help="Restrict HistoSys smoothing to these channels (default: all channels)")

    parser_ws.add_argument('--prune-histosys', action='store_true', default=False,
        help="Enable HistoSys pruning")
    parser_ws.add_argument('--prune-histosys-channels', nargs='*',
        help="Restrict HistoSys smoothing to these channels (default: all channels)")
    parser_ws.add_argument('--prune-histosys-method', choices=('max', 'chi2', 'ks'), default='max',
        help="HistoSys pruning method. Choices: max, chi2, ks (default: max)")
    parser_ws.add_argument('--prune-histosys-threshold', type=float, default=0.1,
        help="Threshold on HistoSys pruning method to determine if shape is significant (default: 0.1)")

    parser_ws.add_argument('--prune-overallsys', action='store_true', default=False,
        help="Enable OverallSys pruning")
    parser_ws.add_argument('--prune-overallsys-channels', nargs='*',
        help="Restrict OverallSys smoothing to these channels (default: all channels)")
    parser_ws.add_argument('--prune-overallsys-threshold', type=float, default=0.5,
        help="Threshold [%%] below which OverallSys components are dropped (default: 0.5)")

    parser_ws.add_argument('--uniform-binning', action='store_true', default=False,
        help="Convert all histograms to uniform binning")

    parser_ws.add_argument('--output-suffix', default=None,
        help="The output ROOT file and directory containing the XML "
             "will have the same names as the measurement names. You "
             "may optionally add a suffix to these names with this option.")

    parser_ws.add_argument('xmlfile')
    parser_ws.set_defaults(op='ws')
    args = parser.parse_args()
    
    context = do_nothing if args.verbose else silence_sout
    log.info("loading RooStats ...")
    with context():
        from rootpy.stats.histfactory import measurements_from_xml, write_measurement, patch_xml
    
    if args.op == 'patch':
        
        patch_xml(args.files, float_precision=args.precision)

    elif args.op == 'diff':

        left = measurements_from_xml(
            args.left, cd_parent=True,
            collect_histograms=True, silence=not args.verbose)
        right = measurements_from_xml(
            args.right, cd_parent=True,
            collect_histograms=True, silence=not args.verbose)
        _diff_sequence_helper(left, right,
            diff_func=diff_measurements, parent=None, precision=args.precision)

    elif args.op == 'ws':
        
        if args.merge_bins:
            args.merge_bins = [
                map(int, token.split(':')) for token in args.merge_bins]
                
        meas = measurements_from_xml(
            args.xmlfile, cd_parent=True,
            collect_histograms=True, silence=not args.verbose)

        for m in meas:
            process_measurement(m,
                fill_empties=args.fill_empties,
                fill_empties_samples=args.fill_empties_samples,
                fill_empties_channels=args.fill_empties_channels,
                rebin=args.rebin,
                rebin_channels=args.rebin_channels,
                merge_bins=args.merge_bins,
                merge_bins_channels=args.merge_bins_channels,
                smooth_histosys=args.smooth_histosys,
                smooth_histosys_iterations=args.smooth_histosys_iterations,
                smooth_histosys_channels=args.smooth_histosys_channels,
                prune_histosys=args.prune_histosys,
                prune_histosys_channels=args.prune_histosys_channels,
                prune_histosys_method=args.prune_histosys_method,
                prune_histosys_threshold=args.prune_histosys_threshold,
                prune_overallsys=args.prune_overallsys,
                prune_overallsys_channels=args.prune_overallsys_channels,
                prune_overallsys_threshold=args.prune_overallsys_threshold,
                uniform_binning=args.uniform_binning)
            write_measurement(m,
                output_suffix=args.output_suffix,
                write_workspaces=True,
                silence=not args.verbose)
        log.info("done")
