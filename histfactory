#!/usr/bin/env python

import rootpy; rootpy.log.basic_config_colorized()
from rootpy.io import root_open
from rootpy.plotting import Hist
from rootpy.utils.silence import silence_sout
import logging; log = logging.getLogger('histfactory')
from math import sqrt


def process_measurement(m,
                        kylefix=False,
                        kylefix_samples=None,
                        kylefix_channels=None,
                        rebin=1,
                        rebin_channels=None,
                        merge_bins=None,
                        merge_bins_channels=None,
                        smooth_histosys=False,
                        smooth_histosys_iterations=1,
                        smooth_histosys_channels=None,
                        prune_histosys=False,
                        prune_overallsys=False,
                        prune_overallsys_threshold=0.5):

    for c in m.channels:
        log.info(
            "processing measurement `{0}` channel `{1}` ...".format(
                m.name, c.name))
        # rebin
        if rebin != 1 and (not rebin_channels or c.name in rebin_channels):
            for s in c.samples:
                log.info("applying rebinning {0:d} on sample `{1}`".format(rebin, s.name))
                s.hist = apply_rebin(s.hist, rebin)
                for histosys in s.histo_sys:
                    histosys.high = apply_rebin(histosys.high, rebin)
                    histosys.low = apply_rebin(histosys.low, rebin)
        # merge bins
        if merge_bins and (not merge_bins_channels or c.name in merge_bins_channels):
            for s in c.samples:
                log.info("merging bins {0} in sample `{1}`".format(
                    ', '.join([':'.join(map(str, r)) for r in merge_bins]),
                    s.name))
                s.hist = apply_merge_bins(s.hist, merge_bins)
                for histosys in s.histo_sys:
                    histosys.high = apply_merge_bins(histosys.high, merge_bins)
                    histosys.low = apply_merge_bins(histosys.low, merge_bins)
        # apply kylefix
        if kylefix and (not kylefix_channels or c.name in kylefix_channels):
            for s in c.samples:
                if kylefix_samples and s.name not in kylefix_samples:
                    continue
                if not is_signal(s):
                    log.info("applying kylefix on sample `{0}`".format(s.name))
                    s.hist = apply_kylefix(s.hist)
                    for histosys in s.histo_sys:
                        histosys.high = apply_kylefix(histosys.high)
                        histosys.low = apply_kylefix(histosys.low)
        # prune overallsys
        # smooth
        # prune shapes
        # fixes that should always be applied
        for s in c.samples:
            s.hist = uniform_binning(zero_negs(s.hist))
            for histosys in s.histo_sys:
                histosys.high = uniform_binning(zero_negs(histosys.high))
                histosys.low = uniform_binning(zero_negs(histosys.low))


def uniform_binning(hist):
    """ 
    For some obscure technical reason, HistFactory can't handle histograms with
    variable width bins. This function takes any histogram and outputs a new
    histogram with constant width bins along all axes by using the bin indices
    of the input histogram as the x-axis of the new histogram.
    """
    if hist.uniform():
        return hist
    llog = log['uniform_binning']
    llog.info("converting histogram {0} to uniform binning".format(hist.name))
    if hist.GetDimension() == 1:
        new_hist = Hist(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    elif hist.GetDimension() == 2:
        new_hist = Hist2D(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            hist.GetNbinsY(), 0, hist.GetNbinsY(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    elif hist.GetDimension() == 3:
        new_hist = Hist3D(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            hist.GetNbinsY(), 0, hist.GetNbinsY(),
            hist.GetNbinsZ(), 0, hist.GetNbinsZ(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    else:
        raise TypeError(
            "unable to apply uniform binning on object "
            "of type {0}".format(type(hist)))
    # copy over the bin contents and errors
    for outbin, inbin in zip(new_hist.bins(), hist.bins()):
        outbin.value = inbin.value
        outbin.error = inbin.error
    return new_hist


def zero_negs(hist):
    """ 
    Return a clone of this histogram with all negative bins set to zero. The
    errors of these bins are left untouched.
    """
    llog = log['zero_negs']
    new_hist = hist.Clone(name=hist.name + '_nonegs', shallow=True)
    applied = False
    for bin in new_hist.bins():
        if bin.value < 0:
            applied = True
            llog.warning(
                "zeroing negative bin {0:d} in {1}".format(
                    bin.idx, hist.name))
            bin.value = 0.
    if applied:
        return new_hist
    return hist


def apply_merge_bins(hist, bin_ranges, axis=0):
    """
    Merge ranges of bins by bin indices.
    `bin_ranges` is a list of 2-tuples of bin index ranges.
    `axis` is the axis along which to merge the bins (0, 1, or 2)
    """
    new_hist = hist.merge_bins(bin_ranges, axis=axis)
    new_hist.name = hist.name + '_merged'
    return new_hist


def apply_rebin(hist, n):
    """
    Rebin the histogram with TH1::Rebin
    """
    if n < 2:
        return hist
    new_hist = hist.Clone(name=hist.name + '_rebin_{0:d}'.format(n), shallow=True)
    new_hist.Rebin(n)
    return new_hist


def shape_is_significant(total, high, low, thresh=0.1):
    """
    For a given shape systematic for background-X, calculate
    s_i=|up_i-down_i|/stat_totBckg_i, where up_i is up variation in bin-i,
    down_i is down variation in bin-I, stat_totBckg_i is statistical
    uncertainty for total background prediction in bin-i. If max(s_i)<0.1,
    then drop this shape systematic for background-X
    """
    for bin_total, bin_high, bin_low in zip(
            total.bins(), high.bins(), low.bins()):
        diff = abs(bin_high.value - bin_low.value)
        if bin_total.error == 0:
            if diff != 0:
                return True
            continue
        sig = abs(bin_high.value - bin_low.value) / bin_total.error
        if sig > thresh:
            return True
    return False


def smooth_shape(nominal, high, low, iterations=1):
    """
    Smooth shape systematics with respect to the nominal histogram by applying
    TH1::Smooth() on the ratio of systematic / nominal.
    """
    ratio_high = high / nominal
    ratio_low = low / nominal
    ratio_high.Smooth(iterations)
    ratio_low.Smooth(iterations)
    return ratio_high * nominal, ratio_low * nominal


def apply_kylefix(hist):
    """
    Return a clone of the input histogram where the empty bins have been filled
    with the average weight and the errors of these bins set to sqrt(<w^2>).
    If no bins were altered, then return the original histogram
    """
    llog = log['kylefix']
    fixed_hist = hist.Clone(name=hist.name + '_kylefix', shallow=True)

    sumW2TotBin = sum([bin.error**2 for bin in hist.bins()])
    avWeightBin = hist.GetSumOfWeights() / hist.GetEntries()
    avW2Bin = sumW2TotBin / hist.GetEntries()

    # now fill empty bins
    applied = False
    for bin in fixed_hist.bins():
        if bin.value < 1E-6:
            llog.warning(
                "filling empty or negative bin {0:d} in {1}".format(
                    bin.idx, hist.name))
            # binContent = avWeight [or avWeightbin]
            bin.value = avWeightBin
            # binError = sqrt(avW2) [or sqrt(avW2Bin)]
            bin.error = sqrt(avW2Bin)
            applied = True
    
    if applied:
        return fixed_hist
    return hist


def is_signal(sample):
    for norm in sample.GetNormFactorList():
        if norm.name == 'SigXsecOverSM':
            return True
    return False


def write_measurement(m, output_suffix=None):
    output_name = m.name
    if output_suffix is not None:
        output_name += '_{0}'.format(output_suffix)
    root_output = 'ws_{0}.root'.format(output_name)
    xml_output = 'xml_{0}'.format(output_name)
    with root_open(root_output, 'recreate') as out:
        log.info("writing {0} ...".format(root_output))
        with silence_sout():
            m.writeToFile(out)
        # get modified measurement
        out_m = out[m.name]
        log.info("writing xml in {0} ...".format(xml_output))
        with silence_sout():
            out_m.PrintXML(xml_output)


if __name__ == '__main__':
    
    from rootpy.extern import argparse
    
    parser = argparse.ArgumentParser(
        description="Apply common operations on an existing HistFactory workspace")
    parser.add_argument('--kylefix', action='store_true', default=False,
        help="Enable application of the KyleFix on background samples")
    parser.add_argument('--kylefix-samples', nargs='*',
        help="Restrict application of KyleFix to these samples (default: all samples)")
    parser.add_argument('--kylefix-channels', nargs='*',
        help="Restrict application of KyleFix to these channels (default: all channels)")
    parser.add_argument('--rebin', type=int, default=1,
        help="Rebin histograms by grouping each N bins. "
             "Use --rebin 2 to merge every group of 2 bins (default: no rebinning)")
    parser.add_argument('--rebin-channels', nargs='*',
        help="Restrict the rebinning to these channels (default: all channels)")
    parser.add_argument('--merge-bins', nargs='*',
        help="Merge bins by ranges of bin indices. "
             "For example, use 1:-12 to merge left bins such that 10 bins on the right "
             "are untouched. Use 1:5 6:10 to merge bins 1 to 5 into one bin and 6 to 10 into one bin. "
             "Note that overflow bin indices are included in the indexing and "
             "that bin index ranges are inclusive of the low and high indices. (default: do not merge bins)")
    parser.add_argument('--merge-bins-channels', nargs='*',
        help="Restrict bin merging to these channels (default: all channels)")
    parser.add_argument('--smooth-histosys', action='store_true', default=False,
        help="Smooth HistoSys histograms (default: False)")
    parser.add_argument('--smooth-histosys-iterations', type=int, default=1,
        help="Number of smoothing iterations in TH1::Smooth(N) to use when "
             "smoothing HistoSys (default: 1)")
    parser.add_argument('--smooth-histosys-channels', nargs='*',
        help="Restrict HistoSys smoothing to these channels (default: all channels)")
    parser.add_argument('--prune-histosys', action='store_true', default=False,
        help="Enable HistoSys pruning")
    parser.add_argument('--prune-overallsys', action='store_true', default=False,
        help="Enable OverallSys pruning")
    parser.add_argument('--prune-overallsys-threshold', type=float, default=0.5,
        help="Threshold [%%] below which OverallSys components are dropped (default: 0.5)")
    parser.add_argument('--output-suffix', default=None,
        help="The output ROOT file and directory containing the XML "
             "will have the same names as the measurement names. You "
             "may optionally add a suffix to these names with this option.")
    parser.add_argument('xmlfile')
    args = parser.parse_args()
    
    if args.merge_bins:
        args.merge_bins = [
            map(int, token.split(':')) for token in args.merge_bins]
    
    log.info("loading RooStats ...")
    with silence_sout():
        from rootpy.stats.histfactory import measurements_from_xml
    
    log.info("reading XML ...")
    meas = measurements_from_xml(args.xmlfile, silence=True)

    for m in meas:
        process_measurement(m,
            kylefix=args.kylefix,
            kylefix_samples=args.kylefix_samples,
            kylefix_channels=args.kylefix_channels,
            rebin=args.rebin,
            rebin_channels=args.rebin_channels,
            merge_bins=args.merge_bins,
            merge_bins_channels=args.merge_bins_channels,
            smooth_histosys=args.smooth_histosys,
            smooth_histosys_iterations=args.smooth_histosys_iterations,
            smooth_histosys_channels=args.smooth_histosys_channels,
            prune_histosys=args.prune_histosys,
            prune_overallsys=args.prune_overallsys,
            prune_overallsys_threshold=args.prune_overallsys_threshold)
        write_measurement(m, output_suffix=args.output_suffix)
