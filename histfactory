#!/usr/bin/env python
# Author: Noel Dawe noel@dawe.me
# License: GPLv3

import os
import math
from math import sqrt
from itertools import izip
from fnmatch import fnmatch

import ROOT
import rootpy; rootpy.log.basic_config_colorized()
from rootpy.io import root_open
from rootpy.plotting import Hist, Hist2D, Hist3D
from rootpy.utils.silence import silence_sout
from rootpy.context import do_nothing

try:
    from collections import OrderedDict
except ImportError:
    from rootpy.extern.ordereddict import OrderedDict

import logging; log = logging.getLogger(os.path.basename(__file__))


def process_measurement(m,
                        split_norm_shape=False,

                        fill_empties=False,
                        fill_empties_samples=None,
                        fill_empties_channels=None,

                        rebin=1,
                        rebin_channels=None,

                        merge_bins=None,
                        merge_bins_channels=None,

                        flat_signal=None,

                        drop_np_names=None,
                        drop_np_types=None,
                        drop_np_samples=None,
                        drop_np_channels=None,

                        symmetrize_names=None,
                        symmetrize_types=None,
                        symmetrize_samples=None,
                        symmetrize_channels=None,

                        smooth_histosys=False,
                        smooth_histosys_iterations=1,
                        smooth_histosys_samples=None,
                        smooth_histosys_channels=None,
                        
                        prune_histosys=False,
                        prune_histosys_samples=None,
                        prune_histosys_channels=None,
                        prune_histosys_blacklist=None,
                        prune_histosys_method='max',
                        prune_histosys_threshold=0.1,

                        prune_overallsys=False,
                        prune_overallsys_samples=None,
                        prune_overallsys_channels=None,
                        prune_overallsys_blacklist=None,
                        prune_overallsys_threshold=0.5,

                        uniform_binning=False,
                        
                        data_is_partially_blind=False,
                
                        hybrid_data=False,
                        hybrid_data_mu=1.0):

    for c in m.channels:
        log.info("processing measurement `{0}` channel `{1}` ...".format(
            m.name, c.name))
         
        # flat signal binning
        if flat_signal is not None:
            sig = [s for s in c.samples if is_signal(s)]
            if sig:
                # get sum of signal
                total_sig = sum([s.hist.Clone(shallow=True) for s in sig])
                # get N quantiles
                quantiles = total_sig.quantiles(flat_signal, strict=True)
                # rebin all histos
                
                data_hist = c.data.hist
                if data_is_partially_blind:
                    # determine first blinded bin
                    for ibin in xrange(data_hist.nbins(0), 0, -1):
                        if data_hist.GetBinContent(ibin) > 0:
                            break
                    log.info("detected data blinding in bin {0:d} and above".format(ibin + 1))
                    blind_cut = data_hist.GetBinCenter(ibin + 1)
                data_hist = apply_rebin(data_hist, quantiles)
                if data_is_partially_blind:
                    # blind from bin containing blind_cut
                    blind_bin = data_hist.FindBin(blind_cut)
                    for ibin in xrange(blind_bin, data_hist.nbins(0) + 2):
                        data_hist.SetBinContent(ibin + 1, 0)
                        data_hist.SetBinError(ibin + 1, 0)
                c.data.hist = data_hist

                for s in c.samples:
                    log.info("applying rebinning {0} on sample `{1}`".format(quantiles, s.name))
                    s.hist = apply_rebin(s.hist, quantiles)
                    for histosys in s.histo_sys:
                        histosys.high = apply_rebin(histosys.high, quantiles)
                        histosys.low = apply_rebin(histosys.low, quantiles)
            else:
                log.warning(
                    "not rebinning to flatten signal in category `{0}` "
                    "since no signal is present".format(c.name))

        # rebin
        if rebin != 1 and matched(c.name, rebin_channels):
            data_hist = c.data.hist
            if data_is_partially_blind:
                # determine first blinded bin
                for ibin in xrange(data_hist.nbins(0), 0, -1):
                    if data_hist.GetBinContent(ibin) > 0:
                        break
                log.info("detected data blinding in bin {0:d} and above".format(ibin + 1))
                blind_cut = data_hist.GetBinCenter(ibin + 1)
            data_hist = apply_rebin(data_hist, rebin)
            if data_is_partially_blind:
                # blind from bin containing blind_cut
                blind_bin = data_hist.FindBin(blind_cut)
                for ibin in xrange(blind_bin, data_hist.nbins(0) + 2):
                    data_hist.SetBinContent(ibin + 1, 0)
                    data_hist.SetBinError(ibin + 1, 0)
            c.data.hist = data_hist
            for s in c.samples:
                log.info("applying rebinning {0:d} on sample `{1}`".format(rebin, s.name))
                s.hist = apply_rebin(s.hist, rebin)
                for histosys in s.histo_sys:
                    histosys.high = apply_rebin(histosys.high, rebin)
                    histosys.low = apply_rebin(histosys.low, rebin)

        # merge bins
        if merge_bins and matched(c.name, merge_bins_channels):
            c.data.hist = apply_merge_bins(c.data.hist, merge_bins)
            for s in c.samples:
                log.info("merging bins {0} in sample `{1}`".format(
                    ', '.join([':'.join(map(str, r)) for r in merge_bins]),
                    s.name))
                s.hist = apply_merge_bins(s.hist, merge_bins)
                for histosys in s.histo_sys:
                    histosys.high = apply_merge_bins(histosys.high, merge_bins)
                    histosys.low = apply_merge_bins(histosys.low, merge_bins)
        
        # split HistoSys into HistoSys and OverallSys components
        if split_norm_shape:
            for s in c.samples:
                apply_split_norm_shape(s)

        # drop NPs by name
        if drop_np_names and matched(c.name, drop_np_channels):
            for s in c.samples:
                if not matched(s.name, drop_np_samples):
                    continue
                if matched('histosys', drop_np_types, ignore_case=True):
                    names = []
                    for np in s.histo_sys:
                        if matched(np.name, drop_np_names, ignore_case=True):
                            names.append(np.name)
                    
                    for name in names:
                        log.info(
                            "removing HistoSys `{0}` from sample `{1}`".format(name, s.name))
                        s.RemoveHistoSys(name)

                if matched('overallsys', drop_np_types, ignore_case=True):
                    names = []
                    for np in s.overall_sys:
                        if matched(np.name, drop_np_names, ignore_case=True):
                            names.append(np.name)

                    for name in names:
                        log.info(
                            "removing OverallSys `{0}` from sample `{1}`".format(name, s.name))
                        s.RemoveOverallSys(name)

        # apply fill_empties
        if fill_empties and matched(c.name, fill_empties_channels):
            for s in c.samples:
                if not matched(s.name, fill_empties_samples):
                    continue
                if not is_signal(s):
                    log.info("applying fill_empties on sample `{0}`".format(s.name))
                    s.hist = apply_fill_empties(s.hist)
                    for histosys in s.histo_sys:
                        histosys.high = apply_fill_empties(histosys.high)
                        histosys.low = apply_fill_empties(histosys.low)

        # smooth
        if smooth_histosys and matched(c.name, smooth_histosys_channels):
            for s in c.samples:
                if not matched(s.name, smooth_histosys_samples):
                    continue
                for histosys in s.histo_sys:
                    smooth_shape(s, s.hist, histosys, smooth_histosys_iterations)

        # prune shapes
        if prune_histosys and matched(c.name, prune_histosys_channels):
            
            # total bkg needed for max method
            if prune_histosys_method == 'max':
                total_bkg = sum([s.hist.Clone(shallow=True) for s in c.samples if not is_signal(s)])
                total_sig = sum([s.hist.Clone(shallow=True) for s in c.samples if is_signal(s)])

            for s in c.samples:
                if not matched(s.name, prune_histosys_samples):
                    continue
                names = []
                if prune_histosys_method == 'max':
                    for histosys in s.histo_sys:
                        if prune_histosys_blacklist and matched(
                                histosys.name,
                                prune_histosys_blacklist):
                            continue
                        if not shape_is_significant(total_sig if is_signal(s) else total_bkg,
                                                    histosys.high, histosys.low,
                                                    prune_histosys_threshold):
                            names.append(histosys.name)

                elif prune_histosys_method == 'chi2':
                    for histosys in s.histo_sys:
                        if prune_histosys_blacklist and matched(
                                histosys.name,
                                prune_histosys_blacklist):
                            continue
                        if not shape_chi2_test(s.hist, histosys.high, histosys.low, prune_histosys_threshold):
                            names.append(histosys.name)

                elif prune_histosys_method == 'ks':
                    for histosys in s.histo_sys:
                        if prune_histosys_blacklist and matched(
                                histosys.name,
                                prune_histosys_blacklist):
                            continue
                        if (histosys.high.KolmogorovTest(s.hist) < prune_histosys_threshold and
                            histosys.low.KolmogorovTest(s.hist) < prune_histosys_threshold):
                            names.append(histosys.name)
                
                for name in names:
                    log.info("removing HistoSys `{0}` from sample `{1}` using method `{2}`".format(
                        name, s.name, prune_histosys_method))
                    s.RemoveHistoSys(name)

        # prune overallsys
        if prune_overallsys and matched(c.name, prune_overallsys_channels):
            for s in c.samples:
                if not matched(s.name, prune_overallsys_samples):
                    continue
                names = []
                for overallsys in s.overall_sys:
                    if prune_overallsys_blacklist and matched(
                            overallsys.name,
                            prune_overallsys_blacklist):
                        continue
                    if (abs(overallsys.high - 1.) * 100. < prune_overallsys_threshold and
                        abs(overallsys.low - 1.) * 100. < prune_overallsys_threshold):
                        names.append(overallsys.name)
                for name in names:
                    log.info("removing OverallSys `{0}` from sample `{1}`".format(name, s.name))
                    s.RemoveOverallSys(name)

        # symmetrize NPs
        if symmetrize_names and matched(c.name, symmetrize_channels):
            for s in c.samples:
                if not matched(s.name, symmetrize_samples):
                    continue
                if matched('histosys', symmetrize_types, ignore_case=True):
                    names = []
                    for np in s.histo_sys:
                        if matched(np.name, symmetrize_names, ignore_case=True):
                            log.info("symmetrizing HistoSys `{0}` in sample `{1}`".format(
                                np.name, s.name))
                            symmetrize_histosys(np, s.hist)
                    
                if matched('overallsys', symmetrize_types, ignore_case=True):
                    names = []
                    for np in s.overall_sys:
                        if matched(np.name, symmetrize_names, ignore_case=True):
                            log.info("symmetrizing OverallSys `{0}` in sample `{1}`".format(
                                np.name, s.name))
                            symmetrize_overallsys(np, nominal=1.)

        # convert to uniform binning
        if uniform_binning:
            c.data.hist = to_uniform_binning(c.data.hist)
            for s in c.samples:
                s.hist = to_uniform_binning(s.hist)
                for histosys in s.histo_sys:
                    histosys.high = to_uniform_binning(histosys.high)
                    histosys.low = to_uniform_binning(histosys.low)
        
        # zero out negatives
        for s in c.samples:
            s.hist = zero_negs(s.hist)
            for histosys in s.histo_sys:
                histosys.high = zero_negs(histosys.high)
                histosys.low = zero_negs(histosys.low)
        
        # construct hybrid data
        if hybrid_data:
            data_hist = c.data.hist
            if data_is_partially_blind:
                # get first bin to construct hybrid data in
                for blind_bin in xrange(data_hist.nbins(0), 0, -1):
                    if data_hist.GetBinContent(blind_bin) > 0:
                        break
                blind_bin += 1
            else:
                blind_bin = 0
            # get sum of background and sum of signal
            total_bkg = sum([s.hist.Clone(shallow=True) for s in c.samples if not is_signal(s)])
            sigs = [s.hist.Clone(shallow=True) for s in c.samples if is_signal(s)]
            if not sigs:
                log.warning(
                    "not constructing hybrid data in channel `{0}` "
                    "because no signal is present".format(c.name))
            else:
                log.info(
                    "constructing hybrid data with mu={0:f} in bin {1:d} and above".format(
                        hybrid_data_mu, blind_bin))
                total_sig = sum(sigs)
                hybrid_data = total_bkg + (total_sig * hybrid_data_mu)
                for ibin in xrange(blind_bin, data_hist.nbins(0) + 2):
                    data_hist.SetBinContent(ibin, hybrid_data.GetBinContent(ibin))
                    data_hist.SetBinError(ibin, hybrid_data.GetBinError(ibin))


def matched(name, patterns, ignore_case=False):
    if not patterns:
        return True
    if ignore_case:
        name = name.lower()
    for pattern in patterns:
        if ignore_case:
            pattern = pattern.lower()
        if fnmatch(name, pattern):
            return True
    return False


def apply_split_norm_shape(s):
    from rootpy.stats.histfactory import split_norm_shape
    for histosys in s.histo_sys:
        log.info("splitting HistoSys `{0}` in sample `{1}`".format(
            histosys.name, s.name))
        norm, shape = split_norm_shape(histosys, s.hist)
        histosys.high = shape.high
        histosys.low = shape.low
        s.AddOverallSys(norm)


def symmetrize_histosys(np, nominal):
    high = np.high.Clone(name=np.high.name + '_symmetrized', shallow=True)
    low = np.low.Clone(name=np.low.name + '_symmetrized', shallow=True)
    for high_bin, low_bin, nom_bin in izip(high.bins(), low.bins(),
                                           nominal.bins()):
        high_value = high_bin.value
        low_value = low_bin.value
        nom_value = nom_bin.value
        delta = max(abs(high_value - nom_value),
                    abs(low_value - nom_value))
        if high_value >= low_value:
            high_bin.value = nom_value + delta
            low_bin.value = nom_value - delta
        else:
            high_bin.value = nom_value - delta
            low_bin.value = nom_value + delta
    np.high = high
    np.low = low


def symmetrize_overallsys(np, nominal=1.):
    delta = max(abs(np.high - nominal), abs(np.low - nominal))
    if np.high >= np.low:
        np.high = nominal + delta
        np.low = nominal - delta
    else:
        np.high = nominal - delta
        np.low = nominal + delta


def shape_chi2_test(nom, up, down, threshold):
    """
    Calculate the Chi^2 of the up and down variations and return True the
    variations are significant given a threshold on the minimum Chi^2 value.
    """
    chi2up = 0.
    chi2dn = 0.
    nbin = 0
    for nom_bin, up_bin, down_bin in izip(
            nom.bins(overflow=False),
            up.bins(overflow=False),
            down.bins(overflow=False)):
        n = nom_bin.value
        u = up_bin.value
        d = down_bin.value
        eup = max(nom_bin.error, up_bin.error)
        edn = max(nom_bin.error, down_bin.error)
        if not (n > 0. and eup > 0. and edn > 0.):
            continue
        chi2up += ((u - n) / eup) ** 2.
        chi2dn += ((d - n) / edn) ** 2.
        nbin += 1
    chi2up = ROOT.TMath.Prob(chi2up, nbin)
    chi2dn = ROOT.TMath.Prob(chi2dn, nbin)
    # return True if the shape should be kept
    return min(chi2up, chi2dn) <= threshold


def shape_is_significant(total, high, low, threshold=0.1):
    """
    For a given shape systematic calculate ``s_i=|up_i-down_i|/stat_total_i``,
    where ``up_i`` is up variation in ``bin_i``, ``down_i`` is down variation
    in ``bin_i``, ``stat_total_i`` is the statistical uncertainty for total
    background prediction in ``bin_i``. If ``max(s_i)<0.1``, then drop this
    shape systematic.
    """
    for bin_total, bin_high, bin_low in zip(
            total.bins(), high.bins(), low.bins()):
        diff = abs(bin_high.value - bin_low.value)
        if bin_total.error == 0:
            if diff != 0:
                return True
            continue
        sig = abs(bin_high.value - bin_low.value) / bin_total.error
        if sig > threshold:
            return True
    return False


def smooth_shape(sample, nominal, histosys, iterations=1):
    """
    Smooth shape systematics with respect to the nominal histogram by applying
    TH1::Smooth() on the ratio of systematic / nominal.
    """
    log.info("smoothing HistoSys `{0}` in sample `{1}`".format(
        histosys.name, sample.name))
    high = histosys.high
    low = histosys.low

    high_name = high.name + '_smoothed_{0}'.format(iterations)
    low_name = low.name + '_smoothed_{0}'.format(iterations)

    nominal_high = nominal.Clone(shallow=True)
    nominal_low = nominal.Clone(shallow=True)

    for bin_high, bin_low, bin_nom in izip(
            high.bins(overflow=True),
            low.bins(overflow=True),
            nominal_high.bins(overflow=True)):
        if bin_nom.value < 1E-3:
            bin_nom.value = (bin_high.value + bin_low.value) / 2.

    ratio_high = high / nominal_high
    ratio_low = low / nominal_low

    ratio_high.Smooth(iterations)
    ratio_low.Smooth(iterations)

    histosys.high = ratio_high * nominal_high
    histosys.low = ratio_low * nominal_low

    histosys.high.name = high_name
    histosys.low.name = low_name


def to_uniform_binning(hist):
    """ 
    For some obscure technical reason, HistFactory can't handle histograms with
    variable width bins. This function takes any histogram and outputs a new
    histogram with constant width bins along all axes by using the bin indices
    of the input histogram as the x-axis of the new histogram.
    """
    log.info("converting histogram `{0}` to uniform binning".format(hist.name))
    if hist.GetDimension() == 1:
        new_hist = Hist(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    elif hist.GetDimension() == 2:
        new_hist = Hist2D(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            hist.GetNbinsY(), 0, hist.GetNbinsY(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    elif hist.GetDimension() == 3:
        new_hist = Hist3D(
            hist.GetNbinsX(), 0, hist.GetNbinsX(),
            hist.GetNbinsY(), 0, hist.GetNbinsY(),
            hist.GetNbinsZ(), 0, hist.GetNbinsZ(),
            name=hist.name + '_uniform_binning', type=hist.TYPE)
    else:
        raise TypeError(
            "unable to apply uniform binning on object "
            "of type {0}".format(type(hist)))
    # copy over the bin contents and errors
    for outbin, inbin in izip(new_hist.bins(), hist.bins()):
        outbin.value = inbin.value
        outbin.error = inbin.error
    return new_hist


def zero_negs(hist):
    """ 
    Return a clone of this histogram with all negative bins set to zero. The
    errors of these bins are left untouched.
    """
    new_hist = hist.Clone(name=hist.name + '_nonegs', shallow=True)
    applied = False
    for bin in new_hist.bins():
        if bin.value < 0:
            applied = True
            log.warning(
                "zeroing negative bin {0:d} in `{1}`".format(
                    bin.idx, hist.name))
            bin.value = 0.
    if applied:
        return new_hist
    return hist


def apply_merge_bins(hist, bin_ranges, axis=0):
    """
    Merge ranges of bins by bin indices.
    `bin_ranges` is a list of 2-tuples of bin index ranges.
    `axis` is the axis along which to merge the bins (0, 1, or 2)
    """
    new_hist = hist.merge_bins(bin_ranges, axis=axis)
    new_hist.name = hist.name + '_merged'
    return new_hist


def apply_rebin(hist, bins, axis=0):
    """
    Rebin the histogram
    """
    if isinstance(bins, int) and bins < 2:
        return hist
    new_hist = hist.rebinned(bins, axis=0)
    if isinstance(bins, int):
        new_hist.name = hist.name + '_rebin_{0:d}'.format(bins)
    else:
        new_hist.name = hist.name + '_rebinned'
    return new_hist


def apply_fill_empties(hist):
    """
    Return a clone of the input histogram where the empty bins have been filled
    with the average weight and the errors of these bins set to sqrt(<w^2>).
    If no bins were altered, then return the original histogram
    """
    fixed_hist = hist.Clone(name=hist.name + '_fill_empties', shallow=True)

    sumW2TotBin = sum([bin.error**2 for bin in hist.bins()])
    avWeightBin = hist.GetSumOfWeights() / hist.GetEntries()
    sqrt_avW2Bin = sqrt(sumW2TotBin / hist.GetEntries())

    applied = False
    for bin in fixed_hist.bins():
        if bin.value < 1E-6:
            log.warning(
                "filling bin {0:d} containing {1:f}+/-{2:f} in "
                "`{3}` with average weight {4:f}+/-{5:f}".format(
                    bin.idx, bin.value, bin.error,
                    hist.name,
                    avWeightBin, sqrt_avW2Bin))
            bin.value = avWeightBin
            bin.error = sqrt_avW2Bin
            applied = True
    
    if applied:
        return fixed_hist
    return hist


def is_signal(sample, poi='SigXsecOverSM'):
    for norm in sample.GetNormFactorList():
        if norm.name == poi:
            return True
    return False


def equal(left, right, precision=1E-7):
    return abs(left - right) < precision


def _get_named(sequence, name):
    for i, thing in enumerate(sequence):
        if thing.GetName() == name:
            return i, thing
    return None, None


def partitioning(left, right):
    """
    Partition each collection into three sets containing the elements that
    overlap between the collections, elements that are only found in the left
    collection and elements that are only found in the right collection.
    """
    overlap = []
    left_only  = []
    right_only = right[:]
    for thing in left:
        idx, other = _get_named(right_only, thing.name)
        if idx is not None:
            overlap.append((thing, other))
            right_only.pop(idx)
        else:
            left_only.append(thing)
    return overlap, left_only, right_only


def _diff_sequence_helper(left, right, diff_func, parent=None, **kwargs):
    differ = False
    overlap, left_only, right_only = partitioning(
        left, right)
    for left_o, right_o in overlap:
        _differ = diff_func(left_o, right_o, **kwargs)
        if _differ:
            if parent is not None:
                log.warning(
                    "{0} differs in {1}".format(
                        left_o, parent))
            else:
                log.warning(
                    "{0} differs".format(
                        left_o))
            differ = _differ
    for coll, sym in ((left_only, '<'), (right_only, '>')):
        for thing in coll:
            log.warning("{0} {1} {2}".format(parent, sym, thing))
            differ = True
    return differ


def diff_histograms(left, right, compare_edges=False, precision=1E-7):
    # compare dimensionality
    if left.GetDimension() != right.GetDimension():
        log.warning(
            "histgrams {0} and {1} differ in dimensionality: {2:d} and {3:d}".format(
                left.name, right.name,
                left.GetDimension(), right.GetDimension()))
        return True
    # compare axis
    axis_names = 'xyz'
    for axis in xrange(left.GetDimension()):
        if left.nbins(axis) != right.nbins(axis):
            log.warning(
                "histograms {0} and {1} differ in the number of bins "
                "along the {2}-axis: {3:d} {4:d}".format(
                    left.name, right.name, axis_names[axis],
                    left.nbins(axis),
                    right.nbins(axis)))
            return True
    differ = False
    # compare contents and errors
    for left_bin, right_bin in izip(left.bins(), right.bins()):
        if not equal(left_bin.value, right_bin.value, precision=precision):
            log.warning(
                "histgrams {0} and {1} differ in content in bin {2:d}: {3:f} {4:f}".format(
                    left.name, right.name, left_bin.idx,
                    left_bin.value, right_bin.value))
            differ = True
        if not equal(left_bin.error, right_bin.error, precision=precision):
            log.warning(
                "histgrams {0} and {1} differ in error in bin {2:d}: {3:f} {4:f}".format(
                    left.name, right.name, left_bin.idx,
                    left_bin.error, right_bin.error))
            differ = True
    return differ


def diff_overallsys(left, right, precision=1E-7):
    differ = False
    if not equal(left.low, right.low, precision=precision):
        differ = True
        log.warning("OverallSys {0} differs for low values: {1:f} {2:f}".format(
            left.name, left.low, right.low))
    if not equal(left.high, right.high, precision=precision):
        differ = True
        log.warning("OverallSys {0} differs for high values: {1:f} {2:f}".format(
            left.name, left.high, right.high))
    return differ


def diff_histosys(left, right, precision=1E-7):
    differ = False
    if diff_histograms(left.low, right.low, precision=precision):
        differ = True
    if diff_histograms(left.high, right.high, precision=precision):
        differ = True
    return differ
    

def diff_samples(left, right, precision=1E-7):
    # compare nominal
    differ = diff_histograms(left.hist, right.hist, precision=precision)
    # compare OverallSys
    _differ = _diff_sequence_helper(left.overall_sys, right.overall_sys,
        diff_func=diff_overallsys, parent=left, precision=precision)
    if _differ:
        differ = differ
    # compare HistoSys
    _differ = _diff_sequence_helper(left.histo_sys, right.histo_sys,
        diff_func=diff_histosys, parent=left, precision=precision)
    if _differ:
        differ = differ
    return differ


def diff_channels(left, right, precision=1E-7):
    return _diff_sequence_helper(left.samples, right.samples,
        diff_func=diff_samples, parent=left, precision=precision)


def diff_measurements(left, right, precision=1E-7):
    return _diff_sequence_helper(left.channels, right.channels,
        diff_func=diff_channels, parent=left, precision=precision)


class ufloat(object):
    def __init__(self, value, stat, syst=None):
        self.value = value
        self.stat = stat
        self.syst = syst

    def __str__(self):
        return repr(self)

    def __repr__(self):
        pos = int(math.floor(math.log10(abs(self.stat))))
        pos = abs(pos) if pos < 0 else 1
        if self.syst is None:
            fmt = '${0:.'+str(pos)+'f} \pm {1:.'+str(pos)+'f}$'
            return fmt.format(self.value, self.stat)
        spos_up = int(math.floor(math.log10(abs(self.syst[0]))))
        spos_up = abs(spos_up) if spos_up < 0 else 1
        spos_dn = int(math.floor(math.log10(abs(self.syst[1]))))
        spos_dn = abs(spos_dn) if spos_dn < 0 else 1
        pos = max(pos, spos_up, spos_dn) 
        fmt = ('${0:.'+str(pos)+'f} \pm {1:.'+str(pos)+'f}$ '
                '${{}}^{{+{2:.'+str(pos)+'f}}}_{{-{3:.'+str(pos)+'f}}}$')
        return fmt.format(self.value, self.stat, self.syst[0], self.syst[1])


def parse_names(names):
    _names = OrderedDict()
    if not names:
        return _names
    for name in names:
        in_name, _, out_name = name.partition('::')
        _names[in_name] = out_name or in_name
    return _names


def yields(m,
           channel_names=None, sample_names=None,
           unblind=False,
           xbin1=1, xbin2=-2):
    channel_names = parse_names(channel_names)
    sample_names = parse_names(sample_names)
    yields = {}
    data = {}
    # get yields for each sample in each channel
    for c in m.channels:
        if c.name not in channel_names:
            channel_names[c.name] = c.name
        if unblind and c.data.hist:
            data[c.name] = ufloat(*c.data.total(
                xbin1=xbin1, xbin2=xbin2))
        for s in c.samples:
            if s.name not in sample_names:
                sample_names[s.name] = s.name
            if s.name not in yields:
                yields[s.name] = {} 
            value = ufloat(*s.total(
                xbin1=xbin1, xbin2=xbin2))
            yields[s.name][c.name] = value
    # get total background and signal
    total_background = {}
    total_signal = {}
    for c in m.channels:
        value = ufloat(*c.total(where=lambda s: not is_signal(s),
            xbin1=xbin1, xbin2=xbin2))
        total_background[c.name] = value
        if c.has_sample_where(is_signal):
            value = ufloat(*c.total(where=is_signal,
                xbin1=xbin1, xbin2=xbin2))
            total_signal[c.name] = value
    # print a LaTeX table
    print r"\begin{tabular}{%s}" % '|'.join('c' * (len(channel_names) + 1))
    print r"\hline" * 2
    print " & ".join(["Process/Category"] + channel_names.values()) + r"\\"
    print r"\hline"
    for sample_name, out_sample_name in sample_names.items():
        channel_yield = yields[sample_name]
        print " & ".join([out_sample_name] +
            [repr(channel_yield[c]) if c in channel_yield else " "
                for c in channel_names.keys()]) + r"\\"
    if total_background:
        print r"\hline"
        print " & ".join(["Total Background"] + 
            [repr(total_background[c]) if c in total_background else " "
                for c in channel_names.keys()]) + r"\\"
    if total_signal:
        print r"\hline"
        print " & ".join(["Total Signal"] + 
            [repr(total_signal[c]) if c in total_signal else " "
                for c in channel_names.keys()]) + r"\\"
    if unblind:
        print r"\hline"
        print " & ".join(["Data"] +
            [repr(data[c]) if c in data else " "
                for c in channel_names.keys()]) + r"\\"
    print r"\hline" * 2
    print r"\end{tabular}"


if __name__ == '__main__':
    
    from rootpy.extern import argparse
    
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False,
        description="""
A script for common operations on HistFactory workspaces.

This script can:

* print LaTeX yields tables
* patch HistFactory XML files by cleaning up the formatting and fixing known
  issues that trigger HistFactory bugs
* list the differences between two workspaces (including differences at the
  histogram level)
* convert histograms to uniform binning
* rebin histograms
* merge specific bins in histograms
* smooth shape (HistoSys) systematics
* prune normalization (OverallSys) systematics
* prune shape (HistoSys) systematics by three separate methods: maximum
  deviation relative to total background statistical uncertainty, Chi2, and KS
* fill empty background bins with the average sample weights

A new ROOT file and new set of XML files will be written out alongside the 
input files with one or more of the above modifications.""")
    
    parser.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")
    parser.add_argument('--verbose', action='store_true', default=False,
        help="Show all HistFactory/RooStats output")

    subparsers = parser.add_subparsers()

    parser_yields = subparsers.add_parser('yields',
        description="Print a tables of yields for all samples and channels",
        add_help=False)
    
    parser_yields.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")
    
    parser_yields.add_argument('--sample-names', nargs='*',
        help="Sample names in the order you want them to appear in the table "
             "rows. Rename samples with input_name::output_name")
    parser_yields.add_argument('--channel-names', nargs='*',
        help="Channel names in the order you want them to appear in the table "
             "columns. Rename channels with input_name::output_name")
    
    parser_yields.add_argument('--xbin1', type=int, default=1,
        help="Bin index along the x-axis to begin integrals (default: 1)")
    parser_yields.add_argument('--xbin2', type=int, default=-2,
        help="Bin index along the x-axis to end integrals (default: -2)")

    parser_yields.add_argument('--unblind', default=False, action='store_true',
        help="Include observed data yields in the tables")
    
    parser_yields.add_argument('xmlfile', metavar='TOP_LEVEL_MEASUREMENT_XML')
    parser_yields.set_defaults(op='yields')

    parser_diff = subparsers.add_parser('diff',
        description="List the differences between two workspaces",
        add_help=False)
    
    parser_diff.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")

    parser_diff.add_argument('-p', '--precision', type=float, default=1E-7,
        metavar='float',
        help="Precision for comparing if two floats are equal (default: 1E-7)")

    parser_diff.add_argument('left', metavar='TOP_LEVEL_MEASUREMENT_XML_A')
    parser_diff.add_argument('right', metavar='TOP_LEVEL_MEASUREMENT_XML_B')
    parser_diff.set_defaults(op='diff')

    
    parser_patch = subparsers.add_parser('patch',
        description="Patch HistFactory XML files",
        add_help=False)

    parser_patch.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")
    
    parser_patch.add_argument('-p', '--precision', type=int, default=3,
        metavar='float',
        help="Number of decimal places to keep in all floats (default: 3)")

    parser_patch.add_argument('files', nargs='+',
        metavar='XML_FILE',
        help="HistFactory XML files")
    
    parser_patch.set_defaults(op='patch')


    parser_ws = subparsers.add_parser('ws',
        description="Create a new workspace with optional modifications",
        add_help=False)
    
    parser_ws.add_argument('-h', '--help', action='help',
        help="Show this help message and exit")

    parser_ws.add_argument('--split-norm-shape', action='store_true', default=False,
        help="Split HistoSys into OverallSys and HistoSys components")
    
    parser_ws.add_argument('--fill-empties', action='store_true', default=False,
        help="Fill empty background bins per sample with the average weight and set "
             "the errors of these bins to sqrt(<w^2>)")
    parser_ws.add_argument('--fill-empties-samples', nargs='*',
        metavar='SAMPLE_NAME',
        help="Restrict application of --fill-empties to these samples (default: all samples)")
    parser_ws.add_argument('--fill-empties-channels', nargs='*',
        metavar='CHANNEL_NAME',
        help="Restrict application of --fill-empties to these channels (default: all channels)")

    parser_ws.add_argument('--rebin', type=int, default=1,
        metavar='int',
        help="Rebin histograms by grouping each N bins. "
             "Use --rebin 2 to merge every group of 2 bins (default: no rebinning)")
    parser_ws.add_argument('--rebin-channels', nargs='*',
        metavar='CHANNEL_NAME',
        help="Restrict the rebinning to these channels (default: all channels)")

    parser_ws.add_argument('--merge-bins', nargs='*',
        metavar='LOW:HIGH',
        help="Merge bins by ranges of bin indices. "
             "For example, use 1:-12 to merge left bins such that 10 bins on the right "
             "are untouched. Use 1:5 6:10 to merge bins 1 to 5 into one bin and 6 to 10 into one bin. "
             "Note that overflow bin indices are included in the indexing and "
             "that bin index ranges are inclusive of the low and high indices. (default: do not merge bins)")
    parser_ws.add_argument('--merge-bins-channels', nargs='*',
        metavar='CHANNEL_NAME',
        help="Restrict bin merging to these channels (default: all channels)")

    parser_ws.add_argument('--flat-signal', type=int, default=None,
        metavar='int',
        help="Rebin all histograms such that signal is flat. "
             "Specify the number of quantiles to use as bin edges in the "
             "rebinned histogram.")

    parser_ws.add_argument('--drop-np-names', nargs='*',
        metavar='NP_NAME',
        help="Remove specific NPs by name")
    parser_ws.add_argument('--drop-np-types', nargs='*',
        metavar='NP_TYPE',
        help="If --drop-np-names is used, restrict the removal to NPs of this type (histosys, overallsys)")
    parser_ws.add_argument('--drop-np-samples', nargs='*',
        metavar='SAMPLE_NAME',
        help="If --drop-np-names is used, restrict the removal to NPs of these samples")
    parser_ws.add_argument('--drop-np-channels', nargs='*',
        metavar='CHANNEL_NAME',
        help="If --drop-np-names is used, restrict the removal to NPs of these channels")
    
    parser_ws.add_argument('--symmetrize-names', nargs='*',
        metavar='NP_NAME',
        help="Symmetrize specific NPs by name")
    parser_ws.add_argument('--symmetrize-types', nargs='*',
        metavar='NP_TYPE',
        help="If --symmetrize-names is used, restrict the symmetrization to NPs of this type (histosys, overallsys)")
    parser_ws.add_argument('--symmetrize-samples', nargs='*',
        metavar='SAMPLE_NAME',
        help="If --symmetrize-names is used, restrict the symmetrization to NPs of these samples")
    parser_ws.add_argument('--symmetrize-channels', nargs='*',
        metavar='CHANNEL_NAME',
        help="If --symmetrize-names is used, restrict the symmetrization to NPs of these channels")

    parser_ws.add_argument('--smooth-histosys', action='store_true', default=False,
        help="Smooth HistoSys histograms (default: False)")
    parser_ws.add_argument('--smooth-histosys-iterations', type=int, default=1,
        metavar='int',
        help="Number of smoothing iterations in TH1::Smooth(N) to use when "
             "smoothing HistoSys (default: 1)")
    parser_ws.add_argument('--smooth-histosys-samples', nargs='*',
        metavar='SAMPLE_NAME',
        help="Restrict HistoSys smoothing to these samples (default: all samples)")
    parser_ws.add_argument('--smooth-histosys-channels', nargs='*',
        metavar='CHANNEL_NAME',
        help="Restrict HistoSys smoothing to these channels (default: all channels)")

    parser_ws.add_argument('--prune-histosys', action='store_true', default=False,
        help="Enable HistoSys pruning")
    parser_ws.add_argument('--prune-histosys-samples', nargs='*',
        metavar='SAMPLE_NAME',
        help="Restrict HistoSys pruning to these samples (default: all samples)")
    parser_ws.add_argument('--prune-histosys-channels', nargs='*',
        metavar='CHANNEL_NAME',
        help="Restrict HistoSys pruning to these channels (default: all channels)")
    parser_ws.add_argument('--prune-histosys-blacklist', nargs='*',
        metavar='NP_NAME',
        help="Do not allow pruning of these HistoSys (default: none)")
    parser_ws.add_argument('--prune-histosys-method', choices=('max', 'chi2', 'ks'), default='max',
        help="HistoSys pruning method. Choices: max, chi2, ks (default: max)")
    parser_ws.add_argument('--prune-histosys-threshold', type=float, default=0.1,
        metavar='float',
        help="Threshold on HistoSys pruning method to determine if shape is significant (default: 0.1)")

    parser_ws.add_argument('--prune-overallsys', action='store_true', default=False,
        help="Enable OverallSys pruning")
    parser_ws.add_argument('--prune-overallsys-samples', nargs='*',
        metavar='SAMPLE_NAME',
        help="Restrict OverallSys pruning to these samples (default: all samples)")
    parser_ws.add_argument('--prune-overallsys-channels', nargs='*',
        metavar='CHANNEL_NAME',
        help="Restrict OverallSys pruning to these channels (default: all channels)")
    parser_ws.add_argument('--prune-overallsys-blacklist', nargs='*',
        metavar='NP_NAME',
        help="Do not allow pruning of these OverallSys (default: none)")
    parser_ws.add_argument('--prune-overallsys-threshold', type=float, default=0.5,
        metavar='float',
        help="Threshold [%%] below which OverallSys components are dropped (default: 0.5)")
    
    parser_ws.add_argument('--uniform-binning', action='store_true', default=False,
        help="Convert all histograms to uniform binning")

    parser_ws.add_argument('--output-suffix', default=None,
        metavar='string',
        help="The output ROOT file and directory containing the XML "
             "will have the same names as the measurement names. You "
             "may optionally add a suffix to these names with this option.")
    
    parser_ws.add_argument('--data-is-partially-blind', action='store_true', default=False,
        help="If data is a 1D histogram and is partially blinded from the "
             "highest bin down to some intermediate bin, then properly blind "
             "the resulting histogram after rebinning and only construct "
             "hybrid data in the blinded region. After rebinning, data is "
             "blinded from the first bin that would contain the edge of the "
             "first blind bin before rebinning. The low edge of the first "
             "blinded bin before rebinning is determined by the last bin with "
             "zero entries moving from right to left.")

    parser_ws.add_argument('--hybrid-data', action='store_true', default=False,
        help="Replace data with the sum of background and signal or if "
             "--data-is-partially-blind then only set the blinded bins to the "
             "sum of background and signal")
    parser_ws.add_argument('--hybrid-data-mu', type=float, default=1.0,
        metavar='float',
        help="The signal strength used to construct the hybrid data (default: 1.0)")

    parser_ws.add_argument('--output-path', default=None,
        metavar='PATH',
        help="Write output under this path (default: current directory)")

    parser_ws.add_argument('xmlfile', metavar='TOP_LEVEL_MEASUREMENT_XML')
    parser_ws.set_defaults(op='ws')
    args = parser.parse_args()
    
    context = do_nothing if args.verbose else silence_sout
    log.info("loading RooStats ...")
    with context():
        from rootpy.stats.histfactory import measurements_from_xml, write_measurement, patch_xml
    
    if args.op == 'patch':
        
        patch_xml(args.files, float_precision=args.precision)
    
    elif args.op == 'yields':
        
        meas = measurements_from_xml(
            args.xmlfile, cd_parent=True,
            collect_histograms=True, silence=not args.verbose)
        for m in meas:
            yields(m,
                sample_names=args.sample_names,
                channel_names=args.channel_names,
                xbin1=args.xbin1,
                xbin2=args.xbin2,
                unblind=args.unblind)

    elif args.op == 'diff':

        left = measurements_from_xml(
            args.left, cd_parent=True,
            collect_histograms=True, silence=not args.verbose)
        right = measurements_from_xml(
            args.right, cd_parent=True,
            collect_histograms=True, silence=not args.verbose)
        _diff_sequence_helper(left, right,
            diff_func=diff_measurements, parent=None, precision=args.precision)

    elif args.op == 'ws':
        
        if args.merge_bins:
            args.merge_bins = [
                map(int, token.split(':')) for token in args.merge_bins]
                
        meas = measurements_from_xml(
            args.xmlfile, cd_parent=True,
            collect_histograms=True, silence=not args.verbose)

        for m in meas:
            process_measurement(m,
                split_norm_shape=args.split_norm_shape,

                fill_empties=args.fill_empties,
                fill_empties_samples=args.fill_empties_samples,
                fill_empties_channels=args.fill_empties_channels,

                rebin=args.rebin,
                rebin_channels=args.rebin_channels,

                merge_bins=args.merge_bins,
                merge_bins_channels=args.merge_bins_channels,

                flat_signal=args.flat_signal,

                drop_np_names=args.drop_np_names,
                drop_np_types=args.drop_np_types,
                drop_np_samples=args.drop_np_samples,
                drop_np_channels=args.drop_np_channels,
                
                symmetrize_names=args.symmetrize_names,
                symmetrize_types=args.symmetrize_types,
                symmetrize_samples=args.symmetrize_samples,
                symmetrize_channels=args.symmetrize_channels,

                smooth_histosys=args.smooth_histosys,
                smooth_histosys_iterations=args.smooth_histosys_iterations,
                smooth_histosys_samples=args.smooth_histosys_samples,
                smooth_histosys_channels=args.smooth_histosys_channels,

                prune_histosys=args.prune_histosys,
                prune_histosys_samples=args.prune_histosys_samples,
                prune_histosys_channels=args.prune_histosys_channels,
                prune_histosys_blacklist=args.prune_histosys_blacklist,
                prune_histosys_method=args.prune_histosys_method,
                prune_histosys_threshold=args.prune_histosys_threshold,

                prune_overallsys=args.prune_overallsys,
                prune_overallsys_samples=args.prune_overallsys_samples,
                prune_overallsys_channels=args.prune_overallsys_channels,
                prune_overallsys_blacklist=args.prune_overallsys_blacklist,
                prune_overallsys_threshold=args.prune_overallsys_threshold,

                uniform_binning=args.uniform_binning,
                
                data_is_partially_blind=args.data_is_partially_blind,
                
                hybrid_data=args.hybrid_data,
                hybrid_data_mu=args.hybrid_data_mu)

            write_measurement(m,
                output_path=args.output_path,
                output_suffix=args.output_suffix,
                write_workspaces=True,
                silence=not args.verbose)
        log.info("done")
